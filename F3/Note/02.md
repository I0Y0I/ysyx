编码器
![[Pasted image 20250902211017.png]]
4-2优先编码器比独热码多了一个与门用来区分A3为1时A4是否为0

![[Pasted image 20250902214938.png]]
多放了一个Valid信号区分0000。
16-4编码器
![[Pasted image 20250902214907.png]]
偷懒，用了Mux，有没有不用的方法？
前导0，16-优先编码器输出-1，优先编码器输出取反
尾随0，倒过来优先编码器取反
前导1和尾随1都先取反在计算
存在一个小问题是没法区分全零、全一这种类型

Mux
![[Pasted image 20250902220142.png]]
![[Pasted image 20250902220558.png]]
扩展成3位就可以了。
比较器
![[Pasted image 20250902220946.png]]
全加器
![[Pasted image 20250902221820.png]]
![[Pasted image 20250902222308.png]]
![[Pasted image 20250902222906.png]]
先创建一个半减器
![[Pasted image 20250902223624.png]]
按照全加器的想法做一个全减器
![[Pasted image 20250902223811.png]]
在创建原码加法器之前，先来讨论一下：
把数分为符号位和数据

| B\A | +      | -      |
| --- | ------ | ------ |
| +   | +(A+B) | -(A-B) |
| -   | +(A-B) | -(A+B) |
进位：!(A^B)&Cadder
不存在借位，但存在取反，若Csub，取A符号的反
因为已经有了四位加法器和四位减法器，这里直接做一个5位原码加法器
这里发现在计算A-B时，如果A<B，会输出绝对值的补码，那么只想到通过两个减法器做这个操作。
![[Pasted image 20250902231916.png]]
目前是用的是这种解法，连线有些乱，分三种情况讨论：
* A、B同号，输出数值为加法器数值，Cout为加法器进位，符号为A符号；
* A、B异号，且A>=B，输出应为A-B减法器，且不借位，符号为A符号；
* A、B异号，且A<B，输出应为B-A减法器，且A-B减法器借位，符号为B符号，即A符号取反。